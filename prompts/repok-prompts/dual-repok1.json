{
    "messages": [
        {"role": "system", "content": "You are a highly accurate assistant that builds well-structured specifications from Java class definitions. Your task is to analyze a provided Java class, accurately interpret its properties and build a `RepOK` method for it. The `RepOK` method should verify that the class maintains its representation invariants. You should consider any information that the class and the list of properties can give you, whether it's comments, method names, or attribute names."},
        {"role": "user", "content": "[[CLASS]]\n```\nimport java.util.HashSet;\nimport java.util.Set;\npublic class Graph {\n    public static class Node {\n        int id;\n        public Node(int id) {\n            this.id = id;\n        }\n    }\n    public static class Edge {\n        Node source;\n        Node destination;\n        public Edge(Node source, Node destination) {\n            this.source = source;\n            this.destination = destination;\n        }\n    }\n    private Set<Node> nodes;\n    private Set<Edge> edges;\n    public Graph() {\n        nodes = new HashSet<>();\n        edges = new HashSet<>();\n    }\n    public void addNode(int id) {\n        nodes.add(new Node(id));\n    }\n    public void addEdge(int sourceId, int destinationId) {\n        Node source = findNodeById(sourceId);\n        Node destination = findNodeById(destinationId);\n        if (source != null && destination != null) {\n            edges.add(new Edge(source, destination));\n        }\n    }\n    private Node findNodeById(int id) {\n        for (Node node : nodes) {\n            if (node.id == id) {\n                return node;\n            }\n        }\n        return null;\n    }\n}\n```\n[[PROPERTIES]]\n1- Null checks for sets: Node set and Edge set must be initialized and not null.\n2- Edge and edge references validity: Each Edge and its source and destination nodes must be present in the node set and not null.\n3- No self-loops: Source and destination nodes in an edge must be different.\n4- Node validity and uniqueness: No node object in the node set can be null. There can be no duplicate nodes (HashSet already enforces this).\n5- No duplicate edges: There can be no duplicate edges (HashSet already enforces this)."},
        {"role": "assistant", "content": "[[REP_OK]]\n```\npublic boolean repOk() {\n    // 1. Ensure the nodes and edges sets are not null\n    if (nodes == null || edges == null) {\n        return false;\n    }\n    // 2. Ensure all edges reference nodes within the graph\n    for (Edge edge : edges) {\n        if (edge == null || edge.source == null || edge.destination == null) {\n            return false; // No edge, source, or destination should be null\n        }\n        if (!nodes.contains(edge.source) || !nodes.contains(edge.destination)) {\n            return false; // Source and destination must exist in nodes\n        }\n    }\n    // 3. Ensure there are no self-loops (edge.source != edge.destination)\n    for (Edge edge : edges) {\n        if (edge.source.equals(edge.destination)) {\n            return false; // No self-loops allowed\n        }\n    }\n    // 4. Verify node validity and uniqueness\n    Set<Integer> nodeIds = new HashSet<>();\n    for (Node node : nodes) {\n        if (node == null) {\n            return false; // No node should be null\n        }\n        if (!nodeIds.add(node.id)) {\n            return false; // Duplicate node IDs detected\n        }\n    }\n    // 5. Explicitly check for duplicate edges\n    Set<String> edgeSet = new HashSet<>();\n    for (Edge edge : edges) {\n        String edgeKey = edge.source.id + \"->\" + edge.destination.id;\n        if (!edgeSet.add(edgeKey)) {\n            return false; // Duplicate edge detected\n        }\n    }\n    // If all checks pass, the representation is valid\n    return true;\n} \n```"},
        {"role": "user", "content": "[[CLASS]]\n```\npublic class BinTree {\n    private class Node {\n        private Node left; // left child\n        private Node right; // right child\n        private int info; // data\n        public Node(int info) {\n            this.info = info;\n        }\n        @Override\n        public String toString() {\n            return \"Node [info=\" + info + \n                   \", left=\" + (left != null ? left.info : \"null\") + \n                   \", right=\" + (right != null ? right.info : \"null\") + \"]\";\n        }\n    }\n    private Node root; // root node\n    private int size = 0; // number of nodes in the tree\n    public void add(int x) {\n        if (root == null) {\n            root = new Node(x);\n            size++;\n        } else {\n            addRecursive(root, x);\n        }\n    }\n    private void addRecursive(Node current, int x) {\n        if (x == current.info) {\n            return; // No duplicates allowed\n        } else if (x < current.info) {\n            if (current.left == null) {\n                current.left = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.left, x);\n            }\n        } else {\n            if (current.right == null) {\n                current.right = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.right, x);\n            }\n        }\n    }\n    public boolean contains(int x) {\n        return containsRecursive(root, x);\n    }\n    private boolean containsRecursive(Node current, int x) {\n        if (current == null) {\n            return false;\n        }\n        if (x == current.info) {\n            return true;\n        }\n        return x < current.info \n               ? containsRecursive(current.left, x) \n               : containsRecursive(current.right, x);\n    }\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"BinTree: \");\n        inorderTraversal(root, builder);\n        return builder.toString();\n    }\n    private void inorderTraversal(Node node, StringBuilder builder) {\n        if (node != null) {\n            inorderTraversal(node.left, builder);\n            builder.append(node.info).append(\" \");\n            inorderTraversal(node.right, builder);\n        }\n    }\n    public int getSize() {\n        return size;\n    }\n}\n```\n[[PROPERTIES]]\n1- Consistent size: The size attribute must be equal to the number of nodes in the tree.\n2- Acyclic structure: The tree structure must be acyclic, i.e., no node should have a path back to itself.\n3- Ordered structure: The tree must maintain the binary search tree property, where the left child of a node has a value less than the parent node, and the right child has a value greater than the parent node.\n4- No duplicate values: No two nodes in the tree should have the same value."},
        {"role": "assistant", "content":"[[REP_OK]]\n```\npublic boolean repOK() {\n    // checks that empty tree has size zero\n    if (root == null)\n        return size == 0;\n    // checks that size is consistent\n    if (numNodes(root) != size)\n        return false;\n    // checks that the input is a tree\n    if (!isAcyclic())\n        return false;\n    // checks that data is ordered\n    if (!isOrdered(root))\n        return false;\n    // checks that there are no duplicate values\n    if (!noDuplicates(root))\n        return false;\n    return true;\n}\nprivate boolean isAcyclic() {\n    Set<Node> visited = new HashSet<Node>();\n    visited.add(root);\n    LinkedList<Node> workList = new LinkedList<Node>();\n    workList.add(root);\n    while (!workList.isEmpty()) {\n        Node current = (Node) workList.removeFirst();\n        if (current.left != null) {\n            // checks that the tree has no cycle\n            if (!visited.add(current.left))\n                return false;\n            workList.add(current.left);\n        }\n        if (current.right != null) {\n            // checks that the tree has no cycle\n            if (!visited.add(current.right))\n                return false;\n            workList.add(current.right);\n        }\n    }\n    return true;\n}\nprivate int numNodes(Node n) {\n    if (n == null)\n        return 0;\n    return 1 + numNodes(n.left) + numNodes(n.right);\n}\nprivate boolean isOrdered(Node n) {\n    return isOrdered(n, -1, -1);\n}\nprivate boolean isOrdered(Node n, int min, int max) {\n    if (n.info == null)\n        return false;\n    if ((min != -1 && n.info <= (min)) || (max != -1 && n.info >= (max)))\n        return false;\n    if (n.left != null)\n        if (!isOrdered(n.left, min, n.info))\n            return false;\n    if (n.right != null)\n        if (!isOrdered(n.right, n.info, max))\n            return false;\n    return true;\n}\nprivate boolean noDuplicates(Node root) {\n    Set<Integer> seen = new HashSet<>();\n    return noDuplicatesHelper(root, seen);\n}\nprivate boolean noDuplicatesHelper(Node node, Set<Integer> seen) {\n    if (node == null) return true;\n    // If the value is already in the set, a duplicate exists\n    if (!seen.add(node.info)) return false;\n    // Recursively check the left and right subtrees\n    return noDuplicatesHelper(node.left, seen) && noDuplicatesHelper(node.right, seen);\n}\n```"},
        {"role": "user", "content": "[[CLASS]]\n```\npublic class LinkedList {\n    private static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    private Node head;\n    private int size;\n    public LinkedList() {\n        head = null;\n        size = 0;\n    }\n    public void add(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        size++;\n    }\n    public int remove() {\n        if (head == null) {\n            throw new IllegalStateException(\"List is empty\");\n        }\n        int removedData = head.data;\n        head = head.next;\n        size--;\n        return removedData;\n    }\n}\n```\n[[PROPERTIES]]"}
    ]
}