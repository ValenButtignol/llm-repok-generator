{
    "messages" : [
        {"role": "system", "content": "You are a highly accurate assistant that builds well-structured specifications from Java class definitions. Your task is to analyze a provided Java class, accurately determine its properties and build a List of them. The properties should help to verify that the class maintains its representation invariants. You should consider any information that the class can give you, whether it's comments, method names, or attribute names."},
        {"role": "user", "content": "[[CLASS]]\n```\nimport java.util.HashSet;\nimport java.util.Set;\npublic class Graph {\n    public static class Node {\n        int id;\n        public Node(int id) {\n            this.id = id;\n        }\n    }\n    public static class Edge {\n        Node source;\n        Node destination;\n        public Edge(Node source, Node destination) {\n            this.source = source;\n            this.destination = destination;\n        }\n    }\n    private Set<Node> nodes;\n    private Set<Edge> edges;\n    public Graph() {\n        nodes = new HashSet<>();\n        edges = new HashSet<>();\n    }\n    public void addNode(int id) {\n        nodes.add(new Node(id));\n    }\n    public void addEdge(int sourceId, int destinationId) {\n        Node source = findNodeById(sourceId);\n        Node destination = findNodeById(destinationId);\n        if (source != null && destination != null) {\n            edges.add(new Edge(source, destination));\n        }\n    }\n    private Node findNodeById(int id) {\n        for (Node node : nodes) {\n            if (node.id == id) {\n                return node;\n            }\n        }\n        return null;\n    }\n}\n```"},
        {"role": "assistant", "content": "[[PROPERTIES]]\n1- Null checks for sets: Node set and Edge set must be initialized and not null.\n2- Edge and edge references validity: Each Edge and its source and destination nodes must be present in the node set and not null.\n3- No self-loops: Source and destination nodes in an edge must be different.\n4- Node validity and uniqueness: No node object in the node set can be null. There can be no duplicate nodes (HashSet already enforces this).\n5- No duplicate edges: There can be no duplicate edges (HashSet already enforces this)."},
        {"role": "user", "content": "[[CLASS]]\n```\npublic class BinTree {\n\n    private class Node {\n        private Node left; // left child\n        private Node right; // right child\n        private int info; // data\n\n        public Node(int info) {\n            this.info = info;\n        }\n\n        @Override\n        public String toString() {\n            return \"Node [info=\" + info + \n                   \", left=\" + (left != null ? left.info : \"null\") + \n                   \", right=\" + (right != null ? right.info : \"null\") + \"]\";\n        }\n    }\n\n    private Node root; // root node\n    private int size = 0; // number of nodes in the tree\n\n    public void add(int x) {\n        if (root == null) {\n            root = new Node(x);\n            size++;\n        } else {\n            addRecursive(root, x);\n        }\n    }\n\n    private void addRecursive(Node current, int x) {\n        if (x == current.info) {\n            return; // No duplicates allowed\n        } else if (x < current.info) {\n            if (current.left == null) {\n                current.left = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.left, x);\n            }\n        } else {\n            if (current.right == null) {\n                current.right = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.right, x);\n            }\n        }\n    }\n\n    public boolean contains(int x) {\n        return containsRecursive(root, x);\n    }\n\n    private boolean containsRecursive(Node current, int x) {\n        if (current == null) {\n            return false;\n        }\n        if (x == current.info) {\n            return true;\n        }\n        return x < current.info \n               ? containsRecursive(current.left, x) \n               : containsRecursive(current.right, x);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"BinTree: \");\n        inorderTraversal(root, builder);\n        return builder.toString();\n    }\n\n    private void inorderTraversal(Node node, StringBuilder builder) {\n        if (node != null) {\n            inorderTraversal(node.left, builder);\n            builder.append(node.info).append(\" \");\n            inorderTraversal(node.right, builder);\n        }\n    }\n\n    public int getSize() {\n        return size;\n    }\n}\n```"},
        {"role": "assistant", "content": "[[PROPERTIES]]\n1- Consistent size: The size attribute must be equal to the number of nodes in the tree.\n2- Acyclic structure: The tree structure must be acyclic, i.e., no node should have a path back to itself.\n3- Ordered structure: The tree must maintain the binary search tree property, where the left child of a node has a value less than the parent node, and the right child has a value greater than the parent node.\n4- No duplicate values: No two nodes in the tree should have the same value."},
        {"role": "user", "content": "[[CLASS]]\n```\npublic class LinkedList {\n    private static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    private Node head;\n    private int size;\n    public LinkedList() {\n        head = null;\n        size = 0;\n    }\n    public void add(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        size++;\n    }\n    public int remove() {\n        if (head == null) {\n            throw new IllegalStateException(\"List is empty\");\n        }\n        int removedData = head.data;\n        head = head.next;\n        size--;\n        return removedData;\n    }\n}\n```"},
        {"role": "assistant", "content": "[[PROPERTIES]]"}
    ]
}