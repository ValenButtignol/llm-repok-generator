SYSTEM: | 
  You are a world class Python programmer.
  Review the API documentation.
  Write five different buggy versions of {function_name} that have the same function signature. If the function signature includes
  parameters with <no value> as a default value, replace the <no value> with None. Each function should call {function_name}
  and modify the output to violate this property for all inputs. Strictly follow the output format below.
  ```python
  def buggy_1(...):
    <buggy 2 code>
  def buggy_2(...):
    <buggy 2 code>
  (...)
  ```
USER: | 
  ### Function Name: `filterAndGroupBy`

  ### API Documentation:
  
  **Description:**

  The `filterAndGroupBy` function filters a collection of elements based on a predicate and then groups the filtered elements by a specified key. This function is useful for organizing data into categories after applying a filter.

  **Parameters:**

  - `collection` (`Collection<T>`):  
    The collection of elements to be filtered and grouped. `T` represents the type of elements in the collection.

  - `filterPredicate` (`Predicate<T>`):  
    A predicate that defines the condition used to filter the elements. Only elements that satisfy this condition will be included in the grouping.

  - `groupingKeyExtractor` (`Function<T, K>`):  
    A function that extracts the key used for grouping the filtered elements. `K` represents the type of the key.

  **Returns:**

  - `Map<K, List<T>>`:  
    A map where the keys are the grouping keys extracted by `groupingKeyExtractor`, and the values are lists of elements that belong to each group. Only filtered elements are included.

  **Exceptions:**

  - `NullPointerException`:  
    Thrown if the `collection`, `filterPredicate`, or `groupingKeyExtractor` is `null`.

  **Example Usage:**

  ```java
  Collection<Person> people = List.of(
      new Person("Alice", "Developer", 30),
      new Person("Bob", "Designer", 40),
      new Person("Charlie", "Developer", 35)
  );

  Predicate<Person> ageFilter = person -> person.getAge() > 30;
  Function<Person, String> groupByProfession = Person::getProfession;

  Map<String, List<Person>> groupedPeople = filterAndGroupBy(people, ageFilter, groupByProfession);

  groupedPeople.forEach((profession, persons) -> {
      System.out.println(profession + ": " + persons);
  });
  ```

  **Notes:**

  - This function is particularly useful in scenarios where you need to process large datasets, first filtering out irrelevant data and then categorizing the remaining data based on specific criteria.
  - The order of elements within each group is maintained as per the original collection.
  - If no elements satisfy the `filterPredicate`, the resulting map will be empty.
  -------------------------------------------------------------------------
  Here is a property of the `filterAndGroupBy` that we would like to test in a property-based test.
  ```filterAndGroupBy(filterAndGroupBy(C, P, G).values().stream().flatMap(List::stream).collect(Collectors.toList()), P, G)
      .equals(filterAndGroupBy(C, P, G))```
  