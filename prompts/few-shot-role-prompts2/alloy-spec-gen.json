{
    "messages" : [
        {"role": "system", "content": "You are a highly accurate assistant that builds well-structured specifications from Java class definitions. Analyze the provided Java class, the classe's purpose, attributes, methods, constructors, and any relationships with other classes. Provide an alloy specification that accurately represents the structure and relationships of the class."},
        {"role": "user", "content": "[[CODE]]\npublic class LinkedList {\n    private static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    private Node head;\n    private int size;\n    public LinkedList() {\n        head = null;\n        size = 0;\n    }\n    public void add(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        size++;\n    }\n    public int remove() {\n        if (head == null) {\n            throw new IllegalStateException(\"List is empty\");\n        }\n        int removedData = head.data;\n        head = head.next;\n        size--;\n        return removedData;\n    }\n}"},
        {"role": "assistant", "content": "[[SPECIFICATION]]\nsig Node {\n    nxt: lone Node\n}\nsig LinkedList {\n    head: lone Node,\n    size: Int\n}\npred validLinkedList(l: LinkedList) {\n    // size should be non-negative\n    l.size >= 0\n    // if list is empty, head and tail should be null\n    (l.size = 0) => (no l.head)\n    // Size consistency: the number of nodes reachable from head should equal size\n    l.size = #l.head.*nxt\n    // Acyclicity: no node should be reachable from itself via 'nxt'\n    all n: Node | n !in n.^nxt\n    // Reachability: every node in the list should be reachable from head\n    all n: Node | n in l.head.*nxt\n}"},  
        {"role": "user", "content": "[[CODE]]\nimport java.util.HashSet;\nimport java.util.Set;\npublic class Graph {\n    public static class Node {\n        int id;\n        public Node(int id) {\n            this.id = id;\n        }\n    }\n    public static class Edge {\n        Node source;\n        Node destination;\n        public Edge(Node source, Node destination) {\n            this.source = source;\n            this.destination = destination;\n        }\n    }\n    private Set<Node> nodes;\n    private Set<Edge> edges;\n    public Graph() {\n        nodes = new HashSet<>();\n        edges = new HashSet<>();\n    }\n    public void addNode(int id) {\n        nodes.add(new Node(id));\n    }\n    public void addEdge(int sourceId, int destinationId) {\n        Node source = findNodeById(sourceId);\n        Node destination = findNodeById(destinationId);\n        if (source != null && destination != null) {\n            edges.add(new Edge(source, destination));\n        }\n    }\n    private Node findNodeById(int id) {\n        for (Node node : nodes) {\n            if (node.id == id) {\n                return node;\n            }\n        }\n        return null;\n    }\n}"},  
        {"role": "assistant", "content": "[[SPECIFICATION]]\nsig Node {}\nsig Graph {\n    nodes: set Node,\n    edges: set Node -> Node\n}\npred validGraph(g: Graph) {\n    // Ensure no self-loops (if needed)\n    all n: Node | (n -> n) !in g.edges\n    // Ensure nodes only exist within the graph\n    all n: Node | n in g.nodes\n    // Ensure edges only exist between nodes within the graph\n    all n1, n2: Node | (n1 -> n2) in g.edges => n1 in g.nodes && n2 in g.nodes\n}"},  
        {"role": "user", "content": "[[CODE]]\nimport java.util.ArrayList;\nimport java.util.List;\npublic class Student {\n    private String name;\n    private int age;\n    private List<String> courses;\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n        this.courses = new ArrayList<>();\n    }\n    public void enroll(String course) {\n        courses.add(course);\n    }\n    // RepOK Method\n    public boolean repOk() {\n        // Check that name is not null and not empty\n        if (name == null || name.isEmpty()) {\n            return false;\n        }\n        // Check that age is within a valid range\n        if (age < 0 || age > 120) {\n            return false;\n        }\n        // Check that courses list is not null\n        if (courses == null) {\n            return false;\n        }\n        return true;\n    }\n}"}
    ]
}