{
    "messages": [
        {"role": "system", "content": "You are a highly accurate assistant that builds well-structured specifications from Java class definitions. Your task is to analyze a provided Java class, accurately determine its properties and build a Java method for each one of them. Each method should verify that the class maintains its representation invariants. You should consider any information that the class can give you, whether it's comments, method names, or attribute names."},
        {"role": "user", "content": "[[CLASS]]\n```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Graph {\n    public static class Node {\n        int id;\n\n        public Node(int id) {\n            this.id = id;\n        }\n    }\n\n    public static class Edge {\n        Node source;\n        Node destination;\n\n        public Edge(Node source, Node destination) {\n            this.source = source;\n            this.destination = destination;\n        }\n    }\n\n    private Set<Node> nodes;\n    private Set<Edge> edges;\n\n    public Graph() {\n        nodes = new HashSet<>();\n        edges = new HashSet<>();\n    }\n\n    public void addNode(int id) {\n        nodes.add(new Node(id));\n    }\n\n    public void addEdge(int sourceId, int destinationId) {\n        Node source = findNodeById(sourceId);\n        Node destination = findNodeById(destinationId);\n        if (source != null && destination != null) {\n            edges.add(new Edge(source, destination));\n        }\n    }\n\n    private Node findNodeById(int id) {\n        for (Node node : nodes) {\n            if (node.id == id) {\n                return node;\n            }\n        }\n        return null;\n    }\n}\n```"},
        {"role": "assistant", "content": "[[PROPERTIES]]\n1- Null checks for sets: Node set and Edge set must be initialized and not null:\n```java\n    public boolean noNullSets() {\n        return nodes != null && edges != null;\n    }\n```\n2- Edge and edge references validity: Each Edge and its source and destination nodes must be present in the node set and not null:\n```java\npublic boolean edgeReferencesValidity() {\n    for (Edge edge : edges) {\n        if (edge == null || edge.source == null || edge.destination == null) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n3- No self-loops: Source and destination nodes in an edge must be different:\n```java\npublic boolean noSelfLoops() {\n    for (Edge edge : edges) {\n        if (edge.source.equals(edge.destination)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n   \n4- Node validity and uniqueness: No node object in the node set can be null. There can be no duplicate nodes (HashSet already enforces this):\n```java\npublic boolean nodeValidityAndUniqueness() {\n    Set<Integer> nodeIds = new HashSet<>();\n    for (Node node : nodes) {\n        if (node == null) {\n            return false; // No node should be null\n        }\n        if (!nodeIds.add(node.id)) {\n            return false; // Duplicate node IDs detected\n        }\n    }\n    return true;\n}\n```\n5- No duplicate edges: There can be no duplicate edges (HashSet already enforces this):\n```java\npublic boolean noDuplicateEdges() {\n    Set<String> edgeSet = new HashSet<>();\n    for (Edge edge : edges) {\n        String edgeKey = edge.source.id + \"->\" + edge.destination.id;\n        if (!edgeSet.add(edgeKey)) {\n            return false; // Duplicate edge detected\n        }\n    }\n    // If all checks pass, the representation is valid\n    return true;\n} \n```"},
        {"role": "user", "content": "[[CLASS]]\n```java\npublic class BinTree {\n    private class Node {\n        private Node left; // left child\n        private Node right; // right child\n        private int info; // data\n        public Node(int info) {\n            this.info = info;\n        }\n        @Override\n        public String toString() {\n            return \"Node [info=\" + info + \n                   \", left=\" + (left != null ? left.info : \"null\") + \n                   \", right=\" + (right != null ? right.info : \"null\") + \"]\";\n        }\n    }\n    private Node root; // root node\n    private int size = 0; // number of nodes in the tree\n    public void add(int x) {\n        if (root == null) {\n            root = new Node(x);\n            size++;\n        } else {\n            addRecursive(root, x);\n        }\n    }\n    private void addRecursive(Node current, int x) {\n        if (x == current.info) {\n            return; // No duplicates allowed\n        } else if (x < current.info) {\n            if (current.left == null) {\n                current.left = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.left, x);\n            }\n        } else {\n            if (current.right == null) {\n                current.right = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.right, x);\n            }\n        }\n    }\n    public boolean contains(int x) {\n        return containsRecursive(root, x);\n    }\n    private boolean containsRecursive(Node current, int x) {\n        if (current == null) {\n            return false;\n        }\n        if (x == current.info) {\n            return true;\n        }\n        return x < current.info \n               ? containsRecursive(current.left, x) \n               : containsRecursive(current.right, x);\n    }\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"BinTree: \");\n        inorderTraversal(root, builder);\n        return builder.toString();\n    }\n    private void inorderTraversal(Node node, StringBuilder builder) {\n        if (node != null) {\n            inorderTraversal(node.left, builder);\n            builder.append(node.info).append(\" \");\n            inorderTraversal(node.right, builder);\n        }\n    }\n    public int getSize() {\n        return size;\n    }\n}\n```"},
        {"role": "assistant", "content": "[[PROPERTIES]]\n1- Consistent size: The size attribute must be equal to the number of nodes in the tree:\n```java\npublic boolean consistentSize() {\n    if (root == null)\n        return size == 0;\n\n    // checks that size is consistent\n    if (numNodes(root) != size)\n        return false;\n}\n\nprivate int numNodes(Node n) {\n    if (n == null)\n        return 0;\n    return 1 + numNodes(n.left) + numNodes(n.right);\n}\n\n```\n\n2- Acyclic structure: The tree structure must be acyclic, i.e., no node should have a path back to itself:\n```java\nprivate boolean isAcyclic() {\n    Set<Node> visited = new HashSet<Node>();\n    visited.add(root);\n    LinkedList<Node> workList = new LinkedList<Node>();\n    workList.add(root);\n    while (!workList.isEmpty()) {\n        Node current = (Node) workList.removeFirst();\n        if (current.left != null) {\n            // checks that the tree has no cycle\n            if (!visited.add(current.left))\n                return false;\n            workList.add(current.left);\n        }\n        if (current.right != null) {\n            // checks that the tree has no cycle\n            if (!visited.add(current.right))\n                return false;\n            workList.add(current.right);\n        }\n    }\n    return true;\n}\n```\n\n3- Ordered structure: The tree must maintain the binary search tree property, where the left child of a node has a value less than the parent node, and the right child has a value greater than the parent node:\n```java\nprivate boolean isOrdered(Node n) {\n    return isOrdered(n, -1, -1);\n}\n\nprivate boolean isOrdered(Node n, int min, int max) {\n    if (n.info == null)\n        return false;\n    if ((min != -1 && n.info <= (min)) || (max != -1 && n.info >= (max)))\n        return false;\n    if (n.left != null)\n        if (!isOrdered(n.left, min, n.info))\n            return false;\n    if (n.right != null)\n        if (!isOrdered(n.right, n.info, max))\n            return false;\n    return true;\n}\n```\n\n4- No duplicate values: No two nodes in the tree should have the same value:\n```java\nprivate boolean noDuplicates(Node root) {\n    Set<Integer> seen = new HashSet<>();\n    return noDuplicatesHelper(root, seen);\n}\n\nprivate boolean noDuplicatesHelper(Node node, Set<Integer> seen) {\n    if (node == null) return true;\n\n    // If the value is already in the set, a duplicate exists\n    if (!seen.add(node.info)) return false;\n\n    // Recursively check the left and right subtrees\n    return noDuplicatesHelper(node.left, seen) && noDuplicatesHelper(node.right, seen);\n}\n```"},
        {"role": "user", "content": "[[CLASS]]\n```java\npublic class LinkedList {\n    private static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    private Node head;\n    private int size;\n    public LinkedList() {\n        head = null;\n        size = 0;\n    }\n    public void add(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        size++;\n    }\n    public int remove() {\n        if (head == null) {\n            throw new IllegalStateException(\"List is empty\");\n        }\n        int removedData = head.data;\n        head = head.next;\n        size--;\n        return removedData;\n    }\n}\n```"},
        {"role": "assistant", "content": "[[PROPERTIES]]"}
    ]
}