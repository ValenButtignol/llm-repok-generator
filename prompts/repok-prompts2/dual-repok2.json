{
    "messages": [
        {"role": "system", "content": "You are a very precise assistant that creates well-structured specifications from Java class definitions. Your task is to analyze a provided Java class, accurately interpret the property associated with it, and create a method that can verifies the fulfillment of the property in that class. You must consider any information that the class and property can provide you, be it comments, method names, or attribute names."},
        {"role": "user", "content": "[[CLASS]]\n```java\nimport java.util.HashSet;\nimport java.util.Set;\npublic class Graph {\n    public static class Node {\n        int id;\n        public Node(int id) {\n            this.id = id;\n        }\n    }\n    public static class Edge {\n        Node source;\n        Node destination;\n        public Edge(Node source, Node destination) {\n            this.source = source;\n            this.destination = destination;\n        }\n    }\n    private Set<Node> nodes;\n    private Set<Edge> edges;\n    public Graph() {\n        nodes = new HashSet<>();\n        edges = new HashSet<>();\n    }\n    public void addNode(int id) {\n        nodes.add(new Node(id));\n    }\n    public void addEdge(int sourceId, int destinationId) {\n        Node source = findNodeById(sourceId);\n        Node destination = findNodeById(destinationId);\n        if (source != null && destination != null) {\n            edges.add(new Edge(source, destination));\n        }\n    }\n    private Node findNodeById(int id) {\n        for (Node node : nodes) {\n            if (node.id == id) {\n                return node;\n            }\n        }\n        return null;\n    }\n}\n```\nProperty: No self-loops. Source and destination nodes in an edge must be different."},
        {"role": "assistant", "content": "[[CODE_PROPERTY]]\n```java\npublic boolean noSelfLoops() {\n    for (Edge edge : edges) {\n        if (edge.source.equals(edge.destination)) {\n            return false; // No self-loops allowed\n        }\n    }\n    return true;\n}\n```"},
        {"role": "user", "content": "[[CLASS]]\n```java\npublic class BinTree {\n    private class Node {\n        private Node left; // left child\n        private Node right; // right child\n        private int info; // data\n        public Node(int info) {\n            this.info = info;\n        }\n    }\n    private Node root; // root node\n    private int size = 0; // number of nodes in the tree\n    public void add(int x) {\n        if (root == null) {\n            root = new Node(x);\n            size++;\n        } else {\n            addRecursive(root, x);\n        }\n    }\n    private void addRecursive(Node current, int x) {\n        if (x == current.info) {\n            return; // No duplicates allowed\n        } else if (x < current.info) {\n            if (current.left == null) {\n                current.left = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.left, x);\n            }\n        } else {\n            if (current.right == null) {\n                current.right = new Node(x);\n                size++;\n            } else {\n                addRecursive(current.right, x);\n            }\n        }\n    }\n    public boolean contains(int x) {\n        return containsRecursive(root, x);\n    }\n    private boolean containsRecursive(Node current, int x) {\n        if (current == null) {\n            return false;\n        }\n        if (x == current.info) {\n            return true;\n        }\n        return x < current.info \n                ? containsRecursive(current.left, x) \n                : containsRecursive(current.right, x);\n    }\n    public int getSize() {\n        return size;\n    }\n}\n```\nProperty: Acyclicity. The tree structure must be acyclic, i.e., no node should have a path back to itself."},
        {"role": "assistant", "content":"[[CODE_PROPERTY]]\n```java\npublic boolean isAcyclic() {\n    Set<Node> visited = new HashSet<Node>();\n    visited.add(root);\n    LinkedList<Node> workList = new LinkedList<Node>();\n    workList.add(root);\n    while (!workList.isEmpty()) {\n        Node current = (Node) workList.removeFirst();\n        if (current.left != null) {\n            // checks that the tree has no cycle\n            if (!visited.add(current.left))\n                return false;\n            workList.add(current.left);\n        }\n        if (current.right != null) {\n            // checks that the tree has no cycle\n            if (!visited.add(current.right))\n                return false;\n            workList.add(current.right);\n        }\n    }\n    return true;\n}\n```"},
        {"role": "user", "content": "[[CLASS]]\n```java\npublic class LinkedList {\n    private static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    private Node head;\n    private int size;\n    public LinkedList() {\n        head = null;\n        size = 0;\n    }\n    public void add(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        size++;\n    }\n    public int remove() {\n        if (head == null) {\n            throw new IllegalStateException(\"List is empty\");\n        }\n        int removedData = head.data;\n        head = head.next;\n        size--;\n        return removedData;\n    }\n}\n```"}
    ]
}